# MarkdownHeaderTextSplitter

### **核心目标**

将一份完整的 Markdown 文档，智能地分割成一系列更小、带有上下文元数据、且长度可控的文本块（Chunks）。这对于后续处理，尤其是为检索增强生成（RAG）模型准备数据源，至关重要。

---

### **主要功能与特性**

1.  **分层分割策略 (Two-Phase Splitting):**

    -   **第一阶段：基于标题的结构化分割。** 它首先会根据 Markdown 的标题 (`#`, `##`, `###` 等) 对文档进行宏观的、结构化的切分。所有位于同一个标题下的内容（直到下一个同级或更高级标题出现前）会被归为一个初始块。
    -   **第二阶段：基于长度的精细化分割。** 在第一阶段的基础上，如果设置了 `chunk_size`，分割器会检查每个初始块的长度。对于超出长度限制的块，它会启用一个递归的、更精细的分割流程，使用预设的分隔符（如段落、换行符、句子、逗号等）将其进一步切分成符合大小要求的小块。

2.  **代码块智能感知 (Code-Aware):**

    -   该分割器能够准确识别 Markdown 中的代码块（由 ` ``` ` 或 `~~~` 包裹）。
    -   在计算文本长度以判断是否需要分割时，**代码块的内容不计入 `chunk_size` 的统计**。
    -   最重要的是，它确保**代码块本身不会被从中间切断**，始终保持其完整性并被包含在某一个最终的文本块中。这对于保留代码的正确性和可读性至关重要。

3.  **自动化的元数据生成 (Context-Aware Metadata):**

    -   在分割时，分割器会自动追踪当前的标题层级。
    -   每一个最终生成的文本块都会附带一个 `metadata` 字典，其中包含了它所属的标题信息（例如 `{'h1': '项目介绍', 'h2': '核心功能'}`）。
    -   这个元数据极大地保留了原文的结构化上下文，使得后续的检索能够更精确地定位到信息的来源。

4.  **高度可配置性 (Highly Configurable):**
    -   **`chunk_size`**: 可以精确控制每个文本块（非代码部分）的最大长度。
    -   **`chunk_overlap`**: 允许在相邻的块之间创建重叠内容，这有助于在进行检索时保持上下文的连续性，防止信息在块的边界处被割裂。
    -   **`headers_to_split_on`**: 用户可以自定义使用哪些级别的标题进行分割。
    -   **`strip_headers`**: 用户可以选择是否在最终的文本块内容中保留标题行本身。
    -   **`separators`**: 用于精细化分割的分隔符列表是完全可定制的，并且支持使用正则表达式，提供了极大的灵活性。

### **一言以蔽之**

这个 `MarkdownHeaderTextSplitter` 不仅仅是一个简单的文本切割工具。它是一个**理解 Markdown 结构**的智能分割器，能够**在保持代码完整性的同时**，将文档切分成**长度可控、并携带结构化上下文元数据**的文本块，是为大语言模型应用（如 RAG）准备高质量语料库的理想工具。
